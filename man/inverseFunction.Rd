% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inverseFunction.R, R/numericalInverseFunction.R
\docType{package}
\name{inverseFunction}
\alias{inverseFunction}
\alias{inverseFunction-package}
\alias{inverseFunction}
\title{Inverse Function}
\usage{
inverseFunction(dvar, fun, interval = c(0, 1), silent = TRUE, ...)
}
\arguments{
\item{dvar}{scalar value. \emph{d}ependent \emph{var}iable, usually writen the cartesian plane as 'y'.}

\item{fun}{A list of parameters (name included as \code{fun}) describing a function.}

\item{interval}{a vector containing the end-points of the interval to be searched for the root.}

\item{silent}{logical: should the report of error messages be suppressed?}

\item{...}{further arguments passed to \code{stats}{uniroot}.}
}
\description{
Computes the numerical inverse of a univariate function

Only computes a sigle inverse. For multiple inverseses, use a (for, while) loop.
}
\examples{
myFun <- function(x, b=3) return(2*x+b)
fe <- list(fun='myFun', b = 4)
# dvar = y = 10 = 2*3 + 4
inverseFunction(dvar = 10, fun = fe, interval = c(-10, 10), silent = TRUE)

# Example 2:
fe <- list(fun = 'pnorm', mean = 3, sd = 2)
# pnorm(4.7, mean = 3, sd = 2) = 0.8023375
inverseFunction(dvar = 0.8023375, fun = fe, interval = c(4, 5), silent = TRUE)

# Example 3:
exy <- cbind(1:5, c(2, 4, 3, 6, 7)); print(exy)
set.seed(1); exy <- exy[sample(1:5), ]
library(bernstein)
library(empiricalDistribution)
empCopulaCountsmatrix <- forwardDifference(empiricalCDF2Dcounts(exy))
eu <- 0.3; ev <- 0.8
et <- bernstein2DderivativeX(v = ev, u = eu, diffEC = empCopulaCountsmatrix)
efun <- list(fun = 'bernstein2DderivativeX', u = eu,
            diffEC = empCopulaCountsmatrix)
inverseFunction(dvar = et, fun = efun)


}
